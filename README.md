## II семестр

## Первое задание
Клиент-серверное приложение для передачи файлов. Клиенты подключаются к серверу, инициируют передачу файла на сервер, сервер сохраняет файл. Наименование файла должен передать также клиент.
- Клиентов может быть много
- Файлы могут быть разного размера
- Сервер должен обрабатывать несколько клиентов одновременно
Клиент/сервер - десктопное или консольное приложение, например.

Реализовать задание тремя разными способами взаимодействия клиентов и сервера:
- по протоколу TCP (4 б.) 
- по протоколу UDP (4 б.) 
- через именованные каналы (4 б.) 

## Второе задание
Реализуем клиент-серверную игру разными способами. Реализовали одним способом - сдали - делаем следующий.
Игра должна быть для двух игроков, игроки подключаются к серверу, сервер находит им соперника, сервер передаёт данные между игроками. Например: морской бой, крестики-нолики и т.п.

| Клиент              | Сервер          | Протокол          |
| -----------         | -----------     | -----------       |
| Консоль             | Консоль         | TCP               |
| Консоль             | Консоль         | HTTP              |
| Консоль             | Веб фреймворк   | HTTP              |
| Браузер HTML/js     | Веб фреймворк   | HTTP              |
| Браузер             | Веб фреймворк   | WebSocket/SignalR |

Во 2 строке имеется чисто взаимодействие по HTTP протоколу без всяких фреймворков, например, со стороны сервера на C# поднять простой HttpListener.
Каждый уровень - 8 б.

## 3 задание (16 б.) 
Реализовать игру из второго задания через телеграм-бота. 
Клиенты - люди, подключающиеся к боту.
Сервер - ваш сервис, читающий сообщения от бота.
Действия - те же самые: соединить двух игроков, передавать между ними ходы. 
Сделать сохранение состояния в отдельной БД (обсудить на паре). 

## I семестр

- [Первое дополнительное задание - бинарные деревья, 5 баллов, 20.11.2021](#task-number-one)
- [Второе задание - kernel32, 10 баллов, 11.12.2021](#task-number-two)
- [Третье задание - git, 5 баллов, 25.12.2021](#task-number-three)
- [Четвёртое задание - docker, 7 баллов, 25.12.2021](#task-number-four)
- [Пятое задание - конкурентность, 4 балла, 25.12.2021](#task-number-five)
- [Шестое задание - мьютекс, 10 баллов, 25.12.2021](#task-number-six)
- [Седьмое задание - бенчмарк, 5 баллов, 25.12.2021](#task-number-seven)
- [Восьмое задание - COM объект, 15 баллов, 25.12.2021](#task-number-eight)
- [Девятое задание - паттерны ООП, 2+ баллов, 25.12.2021](#task-number-nine)

## Task number one
##### Работа с бинарными деревьями
##### Цель: немного познакомиться с индексами, которые часто используюся в СУБД
1 - генерируем 1_000_000 случ строк одинакового размера (Guid.NewGuid например)

2 - каждой строке присваиваем некий случайный идентфикатор, например - хэш строки или случайное целочисленное значение

3 - каждую строку с идентификатором последовательно сохраняем в файле данных

4 - для каждой строки: идентификатор строки и её смещение в байтах в файле вставляем в бинарное дерево из первой лабы (ключ - идентификатор, значение в узлах - смещение). Это нужно чтобы в дальнейшем по ключу находить смещение строки в файле. Такая структура данных называется индексом, часто используется для поиска данных

5 - берём 1000 любых идентификаторов строк из ранее сгенерированных и смотрим что быстрее:

5.1 - последовательный поиск строки в файле?

5.2 - поиск смещения в индексе, затем чтение из файла по смещению?

## Task number two 
##### kernel32
##### Цель: использовать системные вызовы, познакомиться с .NET изнутри, почувствовать себя разработчиком высокоуровневого языка
##### предпочтительнее использовать C#, python и ОС Windows
1 - Написать статический класс со статическими методами (по типу File, Console, etc) - записи в файл, чтения из файла.
Для работы с файлами использовать напрямую системные вызовы (windows - kernel32.dll).
Разработчикам на C# - изучать механизм P/Invoke (https://professorweb.ru/my/csharp/optimization/level6/6_2.php, http://pinvoke.net/default.aspx/kernel32.ReadConsoleInput).
Разработчикам на Python - смотреть в сторону библиотеки ctypes.
Можно поизучать как устроен фреймворк .NET изнутри (https://github.com/dotnet/runtime/tree/main/src/libraries/Common/src/Interop/Windows/Kernel32), для работы с ОС используются те же самые вызовы.

2 - генерировать 1_000_000 случ строк любого размера. Записывать их файл двумя способами - с помощью своего кода, стандартными средствами языка. Что быстрее?

3 - читать сгенерированный файл двумя способами. Что быстрее?

4 - сделать методы для работы с консолью: вывод строки, вывод отдельных символов в позицию, покраска консоли. +5 баллов

## Task number three
##### Git
##### Цель: научиться пользоваться одним из основных средств разработчика - системой контроля версий
1) надо написать githook, если точнее precommit. Который будет вносить изменения в ваш исходный код, конкретнее:
- заменять все слова типа PASSWORD на случ символы.
- если в вашем коде будет фигурная скобка последним символом в строке то перенести её на другую строку (для python можно другой пример форматирования).

Хуки часто применяются для форматирования кода, чтобы держать его в чистоте и аккуратности.

2) ваш проект с гитхуком должен быть в репозитории на гитхабе
- делаете новую ветку
- делаете в ней изменения, которые правятся вашим хуком
- коммит
- пуш ветки
- делаете pull request и аппрувите его
ваш репозиторий должен быть публичным, чтобы по истории комитов можно было увидеть все манипуляции
Это стандартный flow разработки, через feature-ветке и мёрдж-реквесты.

## Task number four
##### Docker
##### Цель: докер де-фактор сейчас стандарт для упаковки приложений, с ним надо быть знакомым
Вообще докер необходим:
- для поднятия внешних зависимостей в локальном окружении (на компьютере разрабочтика), всяких СУБД, очередей и прочего. Чтобы не ставить на комп по 100500 приложенй
- для упаковки разработанных приложений в единый формат со всеми зависимостями, чтобы в рабочем окружении для пользователей поднять ту же версию, что проверил разработчик и тестировщики
В этом задании необходимо упаковать ваше приложение из 1 лабы про бинарные деревья в докер-образ и запустить на его основе контейнер:
1. Создать Dockerfile для вашего приложения
2. Запустить на основе докер файла контейнер (docker build, docker run)
3. Показать список, список контейнеров, логи контейнера - чтобы доказать что всё работает.
4. Подсоединить к контейнеру локальную папку хоста и записать итоговый файл из лабораторной в неё. + 2 балла

## Task number five
##### Конкурентность, многопоточность
- Сгенерировать одновременно N (N > 10) файлов с 100_000 строк следующего вида: `порядковый номер файла: M случайных букв латиницы (M одинаково для всех файлов)`. **Одновременно** - использовать потоки
- **Одновременно** читать эти файлы и записывать строки в один итоговый файл.
Сколько строк в итоговом файле? Должно ли их быть больше? Встретились ли мы тут с какими-нибудь проблемами синхронизации доступа? Если - да, как их решить?

## Task number six
##### Написать свой собственный класс для работы с мьютексами
##### Лучше делать на каком-нибудь высокоуровневом языке - C#, python, etc.
Задачи по решению проблем синхронизации многопоточных приложений довольно часто встречаются на практике. Использовать семаформы/мьютексты разработчикам иногда приходится. В этом задании попробуем чуть-чуть посмотреть, как мьютексы сделаны изнутри.

В предыдущем - 5 - задании необходимо было использовать одно из средств разграничения доступа. В этом надо реализовать собственный класс (по типу Mutex в .NET), который бы реализовывал мьютекс. Он должен иметь два метода - Wait и Release. Должен использовать системные вызовы, в Windows из kernel32. Описание здесь - https://www.pinvoke.net/default.aspx/kernel32/CreateMutex.html.

Далее написанный мьютекс надо заиспользовать в предыдущем - 5 - задании как средство разграничения доступа. Только вместо 10 потоков использовать 10 отдельных процессов или экземпляров приложения. Так как наш мьютекс будет системным, то он должен работать на уровне ОС между разными процессами.

## Task number seven
##### Сортировки и бенчмарк
##### Цель: научиться замерять производительность и эффективность написанного кода
Реализовать 4 алгоритма сортировки. Выполнить замеры работы каждого из них на массиве из случайных неупорядоченных элементов размеров в 1000. Для замеров производительности использовать соответствующие библиотеки из языка, на котором вы пишете. В C#/.NET это BenchmarkDotNet, померять также расход памяти (для C# проставить атрибут MemoryDiagnoser).

## Task number eight
##### COM объекты
Цель этой лабораторной реализовать простую игру в консоли и как десктопное приложение. Логика работы будет реализована в отдельном COM объекте, который должен быть заиспользован в консольном приложении и в десктопном. Консоль и десктопное приложение отвечают лишь за отображение и вызов COM объекта. Реализовывать проще на C#/Windows.

Описание игры: игрок управляет ракеткой внизу поля, двигает влево-вправо кнопками. Нажимая пробел, выпускает пулю которая летит вверх. Сверху игрового поля находятся блоки. Пуля, попадаю в какой либо блок, уничтожает его. Блоки появляются вверху поля сплошной полосой. С определённой скоростью двигаются вниз. Когда какой-либо из блоков достигнет низа игрового поля - игра заканчивается поражением. Когда игрок разобьёт все блоки - игра заканчивается победой. В общем, что-то по типу Space Invaders только в упрощенном варианте.

Игра должна быть конфигурируемой. Через файл настроек должны задаваться: размер игрового поля, кол-во блоков для победы, скорость движения блоков (например, количество секунд через которые появляется новая полоса блоков, а старая смещается вниз), скорость движения пули, etc.

Центральная часть игры - COM объект, реализующий всю логику работы. Он читает конфигурационные файлы, и вызов его метода (типа GameLoop) выдаёт игровое поле на котором нарисованы блоки, пули, ракета игрока. Так же этот метод возвращает флаги окончания игры с победой или поражением. Так же этот метод принимает результат пользоватеского движения - нажатие кнопок влево-вправо, был ли нажат пробел, чтобы отрисовать пулю. Пример простого COM объекта - https://github.com/drmckay-kirill/dev_tech_labs/tree/master/ComDemoLib/ComDemoLib.

Нужны два приложения - консольное и десктопное (например, WPF). Они вызывают COM объект с целью получения игрового поля. Их задача лишь отрисовать его, то есть только взаимодействие с пользователем. Игровой логики в этих приложениях должно быть по минимуму.

## Task number nine
##### Паттерны объектно-ориентированного программирования
##### Цель: ООП - распространённый подход в различных системах, необходимо быть с ним знакомым.
За каждый шаблон по 2 балла. Хорошее описание шаблонов ООП приведено здесь - https://refactoring.guru/ru/design-patterns/catalog. Надо продемонстрировать примеры реализации различных паттернов и быть готовым ответить на вопросы. Несмотря на то что примеры из заданий будут выглядеть искусственными, шаблоны ООП must have при разработке сложных систем на таких языках как C#, Java, etc.

**Фабрика**. Продолжим работу на примере бинарного дерева. Предположим, что нам нужно дерево, которое умеет работать с узлами, хранящими элементы разного типа. Пусть у нас будут следующие интерфейсы: `ITree`, generic `INode<T>`. Соответствующие классы: `Tree`, `Node<int>`, `Node<long>`, `Node<byte>`, `Node<string>`, etc. Написать фабричные методы для создания узлов разных типов. Создать дерево из узлов разных типов, используя соответствующие фабрики. Пусть каждый узел реализует `Print` из интерфейса, вывести бинарное дерево.

**Строитель**. Реализовать построитель бинарного дерева (см. паттерн fluent builder). Пусть построитель реализует методы `AddIntegerNode`, `AddStringNode`, `AddLongNode`, `AddByteNode`, etc. Эти методы принимают на вход параметры соответствующего типа и реализуют вставку в бинарное дерево. Предположим, что строки могут быть только числами (чтобы все эти типы можно было сравнивать между собой). Метод `Build` возвращает экземпляр класса `Tree`, который и является нашим деревом. Надо создать бинарное дерево, используя построитель и его методы. Вывести бинарное дерево.
